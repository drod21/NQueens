/* ==================================================================
  Programmers: Conner Wulf (connerwulf@mail.usf.edu),
               Derek Rodriguez (derek23@mail.usf.edu)
	             David Hoambrecker (david106@mail.usf.edu)

  To Compile use: nvcc -o queens proj3-Nqueens.cu
  you can specify the board size by compiling with: nvcc  -o queens proj3-Nqueens.cu -DNUM=a
  * where a must be >= 4 and <= 22

  The program reads in 2 arguments, the first is the number of tuples generated by blockIdx.x
                                    the second is the number of groups of columns, size multiple of board size.
                                    ex. ./queens 4 1000 (based on board size is 12)
   ==================================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/time.h>
#include <cuda_runtime.h>
#include <cuda.h>

using namespace std;
static int total = 0;
struct timezone Idunno;
struct timeval startTime, endTime;
long *answer;

#ifndef NUM
 #define NUM 10
#endif

 __device__ void findSum(long *d_answer, int nBX, int nBY, long *d_count)
 {
   int num_Blocks = gridDim.x *gridDim.y;
   int gridRowSize = powf(NUM, nBX);
   *d_count = 0;

   if(NUM % 2 == 0)
   {
       for(int t = 0; t < num_Blocks; t++)
       {
         *d_count += d_answer[t];
       }
       *d_count *= 2;
   }

   else
   {
     int SegBlockNum = num_Blocks / nBY;

     for(int q = 0; q < nBY; q++)
     {

       int begin = q * SegBlockNum;

       for(int b = begin; b < begin + SegBlockNum - gridRowSize; b++)
       {
         *d_count += d_answer[b];
       }
     }
     *d_count *= 2;

     for(int f = 0; f < nBY; f++)
     {

       for( int e = f * SegBlockNum + SegBlockNum - gridRowSize; e < f * SegBlockNum + SegBlockNum; e++)
       {
         *d_count += d_answer[e];
       }
     }
   }
 }

int isAllowed(int board[NUM][NUM], int row, int col, int n)
{
  int x,y;

  for (x = 0; x < col; x++)
  {
    if(board[row][x] == 1)
    {
      return 0;
    }
  }
  for(x = row, y = col; x >= 0 && y >= 0; x--, y--)
    {
      if (board[x][y] == 1)
      {
        return 0;
      }
    }
  for(x = row, y = col; x < n && y >= 0; x++, y--)
  {
    if (board[x][y] == 1)
    {
      return 0;
    }
  }
 return 1;
}
// CPU Solver for N-queens problem
int Solver(int board[NUM][NUM], int col, int n)
{
  if (col >= n)
  {
    total++;
    return 1;
  }

  int nextState = 0;

  for(int k = 0; k < n; k++)
  {
    if (isAllowed(board,k,col, n))
    {
      board[k][col] = 1;
      nextState = Solver(board, col + 1, n);
      board[k][col] = 0;
    }
  }
  return nextState;
}

__global__ void kernel(long *d_answer, int SegSize, int nBX, int nBY, int genNum, int GPUSum, long *d_count) {

	__shared__ long sol[NUM][NUM];
	__shared__ long tups[NUM][NUM][NUM];

  int wrongCount = 0;
		
	int totalGenerated = powf(NUM, genNum);
	int tupCount = nBX;
	
	int blockYSeg = blockIdx.y / SegSize;
	int workLoad = totalGenerated / nBY; 
	int runOff = totalGenerated - workLoad * nBY;
	
	sol[threadIdx.x][threadIdx.y] = 0;
	tups[threadIdx.x][threadIdx.y][0] = blockIdx.y % SegSize;
	
	int temp = blockIdx.x;
	for(int i = 1; i <= nBX; i++){
		tups[threadIdx.x][threadIdx.y][i] = temp % NUM;
		temp = temp / NUM;
	}
	tups[threadIdx.x][threadIdx.y][++tupCount] = threadIdx.x;
	tups[threadIdx.x][threadIdx.y][++tupCount] = threadIdx.y;
	
	for(int k = tupCount; k > 0; k--){
		for(int m = k - 1, count = 1; m >= 0; m--, count++){
			wrongCount += tups[threadIdx.x][threadIdx.y][k] == tups[threadIdx.x][threadIdx.y][m];
			wrongCount += (tups[threadIdx.x][threadIdx.y][k] - count) == tups[threadIdx.x][threadIdx.y][m];
			wrongCount += (tups[threadIdx.x][threadIdx.y][k] + count) == tups[threadIdx.x][threadIdx.y][m]; 
		}
	}
	
	if(wrongCount == 0){
		int begin = blockYSeg * workLoad;
		for(int c = begin; c < begin + workLoad + (blockYSeg == nBY - 1) * runOff; c++) {
			int temp = c;
			for(int q = 0, z = tupCount + 1; q < genNum; q++, z++){
				tups[threadIdx.x][threadIdx.y][z] = temp % NUM;
				temp = temp / NUM;
			}
			
			for(int a = 0; a < genNum && wrongCount == 0; a++){
				for(int b = 0; b < genNum && wrongCount == 0; b++){
					wrongCount += tups[threadIdx.x][threadIdx.y][tupCount + 1 + a] == tups[threadIdx.x][threadIdx.y][tupCount + 1 + b] && a != b;
        }
			}
			
			for(int k = NUM - 1; k > wrongCount * NUM; k--){
				for(int m = k - 1, count = 1; m >= 0; m--, count++){
					wrongCount += tups[threadIdx.x][threadIdx.y][k] == tups[threadIdx.x][threadIdx.y][m];
					wrongCount += (tups[threadIdx.x][threadIdx.y][k] - count) == tups[threadIdx.x][threadIdx.y][m]; 
					wrongCount += (tups[threadIdx.x][threadIdx.y][k] + count) == tups[threadIdx.x][threadIdx.y][m];
				}
			}
			sol[threadIdx.x][threadIdx.y] += !(wrongCount);
			wrongCount = 0;
		}
	}
	__syncthreads();
  if(threadIdx.x == 0 && threadIdx.y == 0)
  {
		long total = 0;
		
    for(int i =0; i < NUM; i++)
    {
      for(int j = 0; j < NUM; j++)
      {
				total += sol[i][j];
			}
		}
		
		d_answer[gridDim.x * blockIdx.y + blockIdx.x] = total;
		
	}
	
	__syncthreads();
	
  if(GPUSum == 1)
  {
    findSum(d_answer, nBX, nBY, d_count);
	}
} 

double report_running_time() {
	long sec_diff, usec_diff;
	gettimeofday(&endTime, &Idunno);
	sec_diff = endTime.tv_sec - startTime.tv_sec;
	usec_diff= endTime.tv_usec-startTime.tv_usec;
	if(usec_diff < 0) {
		sec_diff --;
		usec_diff += 1000000;
	}
	printf("Running time for CPU version: %ld.%06ld\n", sec_diff, usec_diff);
	return (double)(sec_diff*1.0 + usec_diff/1000000.0);
}

int main(int argc, char **argv) {

  if(argc < 4) {

    printf("\nError, too few arguments. Usage: ./queens 1 4 1\n");
    return -1;
  }

  const int NUM_TUPLEX = atoi(argv[1]);
  const int NUM_TUPLEY = atoi(argv[2]);
  int GPUSum = atoi(argv[3]);
  const int generatedNum = NUM - 3 - NUM_TUPLEX;
  long count = 0;
  cudaEvent_t start, stop;
  cudaError_t res;
  float elapsedTime;

  if(generatedNum < 0){
    printf("\nThe numbers generated iteratively cannot be less than 0.\n");
    return 0;
  }

  if(NUM < 4  || NUM > 22){
    printf("\nN(%d) must be between 4 and 22 inclusive\n", NUM);
    return 0;
  }
  if(GPUSum != 0 && GPUSum != 1)
  {
    printf("\nThe GPU sum identifier(%d) must be a 0 or 1, only\n", GPUSum);
    return 0;
  }
  if(NUM_TUPLEX < 1){
    printf("\nThe number of tuples generated by each block's X coordinate value must be >= 1\n");
    return 0;
  }
  if(NUM_TUPLEY > pow(NUM, generatedNum)){
    printf("\n number of groups of columns must be less than or equal to N^(N - 3 - (1st ARG))\n");
    return 0;
  }
  int board[NUM][NUM];

  for (int i = 0; i < NUM; i++) {
    for (int j = 0; j < NUM; j++) {
      board[i][j] = 0;
    }
  }

  int WIDTH = pow(NUM, NUM_TUPLEX);
  int YSegmentSize = (NUM / 2) + (NUM % 2);
  int HEIGHT = YSegmentSize * NUM_TUPLEY;
  int NUM_BLOCKS = WIDTH * HEIGHT;
  answer = (long *) malloc (sizeof(long) * NUM_BLOCKS);

  long *d_answer;
  long *d_count;

 
  cudaMalloc((void **) &d_count, sizeof(long));
  res = cudaMalloc((void **) &d_answer, sizeof(long) * NUM_BLOCKS);
  if(res != cudaSuccess) {
    printf("error allocating memory. exiting.\n");
    return 0;
  }

  dim3 block(NUM, NUM);
  dim3 grid(WIDTH, HEIGHT);
  cudaMemcpy(d_count, &count, sizeof(long), cudaMemcpyHostToDevice);

  res = cudaEventCreate(&start);
  if(res != cudaSuccess) {
    printf("error starting event. exiting.\n");
    return 0;
  }
  cudaEventCreate(&stop);
  cudaEventRecord(start, 0);

  kernel<<<grid, block>>>(d_answer, YSegmentSize, NUM_TUPLEX, NUM_TUPLEY, generatedNum, GPUSum, d_count);
  cudaDeviceSynchronize();
  cudaEventRecord(stop, 0);
  cudaEventSynchronize(stop);
  cudaEventElapsedTime(&elapsedTime, start, stop);

  res = cudaMemcpy(answer,d_answer, sizeof(long) * NUM_BLOCKS, cudaMemcpyDeviceToHost);
  if(res != cudaSuccess) {
    printf("error copying memory. exiting.\n");
  }

  cudaMemcpy(&count, d_count, sizeof(long), cudaMemcpyDeviceToHost);
  srand(1);
  gettimeofday(&startTime, &Idunno);
  Solver(board, 0, NUM);


  const char* errorString = cudaGetErrorString(cudaGetLastError());
  printf("GPU Error: %s\n", errorString);
  
    


  if(GPUSum == 0)
  {
    
    printf("\nTotal sol(CPU): %d boards\n", total);
    report_running_time();
  }
  else if (GPUSum == 1)
  {
    printf("\nTotal sol(GPU): %li boards\n", count);
    printf("GPU Time: %f secs\n\n", (elapsedTime * 0.001));
  }

  cudaEventDestroy(start); 
  cudaEventDestroy(stop);
    
  cudaFree(d_answer);
  
 	free(answer);
  return 0;
}