/* ==================================================================
  Programmers: Conner Wulf (connerwulf@mail.usf.edu),
               Derek Rodriguez (derek23@mail.usf.edu)
	             David Hoambrecker (david106@mail.usf.edu)

  To Compile use: nvcc -o queens proj3-Nqueens.cu
  you can specify the board size by compiling with: nvcc  -o queens proj3-Nqueens.cu -DNUM=a
  * where a must be >= 4 and <= 22

  The program reads in 2 arguments, the first is the number of tuples generated by blockIdx.x
                                    the second is the number of groups of columns, size multiple of board size.
                                    ex. ./queens 4 1000 (based on board size is 12)
   ==================================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/time.h>
#include <cuda_runtime.h>
#include <cuda.h>

using namespace std;
static int total = 0;
struct timezone Idunno;
struct timeval startTime, endTime;
long long *answer;

#ifndef NUM
 #define NUM 10
#endif

 __device__ void findSum(long long *d_answer, int nBX, int nBY, long *d_count)
 {
   int num_Blocks = gridDim.x *gridDim.y;
   int gridRowSize = powf(NUM, nBX);
   *d_count = 0;

   if(NUM % 2 == 0)
   {
       for(int t = 0; t < num_Blocks; t++)
       {
         *d_count += d_answer[t];
       }
       *d_count *= 2;
   }

   else
   {
     int SegBlockNum = num_Blocks / nBY;

     for(int q = 0; q < nBY; q++)
     {

       int begin = q * SegBlockNum;

       for(int b = begin; b < begin + SegBlockNum - gridRowSize; b++)
       {
         *d_count += d_answer[b];
       }
     }
     *d_count *= 2;

     for(int f = 0; f < nBY; f++)
     {

       for( int e = f * SegBlockNum + SegBlockNum - gridRowSize; e < f * SegBlockNum + SegBlockNum; e++)
       {
         *d_count += d_answer[e];
       }
     }
   }
 }

//CPU helper function to test is a queen can be placed
int isAllowed(int board[NUM][NUM], int row, int col, int n)
{
  int x,y;

  //left check
  for (x = 0; x < col; x++)
  {
    if(board[row][x] == 1)
    {
      return 0;
    }
  }
  //check left diagonal up
  for(x = row, y = col; x >= 0 && y >= 0; x--, y--)
    {
      if (board[x][y] == 1)
      {
        return 0;
      }
    }
  for(x = row, y = col; x < n && y >= 0; x++, y--)
  {
    if (board[x][y] == 1)
    {
      return 0;
    }
  }
 return 1;
}
// CPU Solver for N-queens problem
int Solver(int board[NUM][NUM], int col, int n)
{
  if (col >= n)
  {
    total++;
    return 1;
  }

  int nextState = 0;

  for(int k = 0; k < n; k++)
  {
    if (isAllowed(board,k,col, n))
    {
      board[k][col] = 1;
      nextState = Solver(board, col + 1, n);
      board[k][col] = 0;
    }
  }
  return nextState;
}

__global__ void kernel(long long *d_answer, int SegSize, int nBX, int nBY, int genNum, int GPUSum, long *d_count) {

	__shared__ long long sol[NUM][NUM];
	__shared__ long long tups[NUM][NUM][NUM];

  int wrongCount = 0;
		
	int totalGenerated = powf(NUM, genNum);
	int tupCount = nBX;
	
	int blockYSeg = blockIdx.y / SegSize;
	int workLoad = totalGenerated / nBY; 
	int runOff = totalGenerated - workLoad * nBY;
	
	sol[threadIdx.x][threadIdx.y] = 0;
	tups[threadIdx.x][threadIdx.y][0] = blockIdx.y % SegSize;
  __syncthreads();
	
	//set tuple(s) by block X value
	int temp = blockIdx.x;
	for(int i = 1; i <= nBX; i++){
		tups[threadIdx.x][threadIdx.y][i] = temp % NUM;
		temp = temp / NUM;
	}
	
	
	//set tuples by thread value
	tups[threadIdx.x][threadIdx.y][++tupCount] = threadIdx.x;
	tups[threadIdx.x][threadIdx.y][++tupCount] = threadIdx.y;
	
  __syncthreads();
	
	
	//check if thread is valid at this point
	for(int k = tupCount; k > 0; k--){
		for(int m = k - 1, count = 1; m >= 0; m--, count++){
			//same row
			wrongCount += tups[threadIdx.x][threadIdx.y][k] == tups[threadIdx.x][threadIdx.y][m];
			
			//diag upleft
			wrongCount += (tups[threadIdx.x][threadIdx.y][k] - count) == tups[threadIdx.x][threadIdx.y][m];
			
			//diag downleft
			wrongCount += (tups[threadIdx.x][threadIdx.y][k] + count) == tups[threadIdx.x][threadIdx.y][m]; 
		}
	}
	
	if(wrongCount == 0){
	
		//iterate through all numbers to generate possible sol thread must check
		//does not do if thread is already not valid at this point
		int begin = blockYSeg * workLoad;
		for(int c = begin; c < begin + workLoad + (blockYSeg == nBY - 1) * runOff; c++) {
	    __syncthreads();
			
			//generate last values in tuples, convert to base N and store to tups array
			int temp = c;
			for(int q = 0, z = tupCount + 1; q < genNum; q++, z++){
				tups[threadIdx.x][threadIdx.y][z] = temp % NUM;
				temp = temp / NUM;
			}
			
			//checks that the genNum tuples values are indeed unique (saves work overall)
			for(int a = 0; a < genNum && wrongCount == 0; a++){
				for(int b = 0; b < genNum && wrongCount == 0; b++){
					wrongCount += tups[threadIdx.x][threadIdx.y][tupCount + 1 + a] == tups[threadIdx.x][threadIdx.y][tupCount + 1 + b] && a != b;
        }
			}
			
			//check one solution
			for(int k = NUM - 1; k > wrongCount * NUM; k--){
				for(int m = k - 1, count = 1; m >= 0; m--, count++){
					//same row
					wrongCount += tups[threadIdx.x][threadIdx.y][k] == tups[threadIdx.x][threadIdx.y][m];
					
					//diag upleft
					wrongCount += (tups[threadIdx.x][threadIdx.y][k] - count) == tups[threadIdx.x][threadIdx.y][m]; 
					
					//diag downleft
					wrongCount += (tups[threadIdx.x][threadIdx.y][k] + count) == tups[threadIdx.x][threadIdx.y][m];
				}
			}
			
			//add 1 to solution total if nothing wrong
			sol[threadIdx.x][threadIdx.y] += !(wrongCount);
			
			//reset total wrong
			wrongCount = 0;
		}
	
	}
		
	//sync the threads so that thread 0 can make the calculations
	__syncthreads();
	
	//have thread 0 sum for all threads in block to get block total
  if(threadIdx.x == 0 && threadIdx.y == 0)
  {
		//ensure that the block total value is 0 initially
		long long total = 0;
		
		//iterate through each threads solution and add it to the block total
    for(int i =0; i < NUM; i++)
    {
      for(int j = 0; j < NUM; j++)
      {
				//use local var
				total += sol[i][j];
			}
		}
		
		//store to global memory
		d_answer[gridDim.x * blockIdx.y + blockIdx.x] = total;
		
	}
	
	//sync the threads so that calculations can be made
	__syncthreads();
	
	//have the first thread in the first block sum up the block sums to return to the CPU
  if(GPUSum == 1)
  {
    findSum(d_answer, nBX, nBY, d_count);
	}
} 

double report_running_time() {
	long sec_diff, usec_diff;
	gettimeofday(&endTime, &Idunno);
	sec_diff = endTime.tv_sec - startTime.tv_sec;
	usec_diff= endTime.tv_usec-startTime.tv_usec;
	if(usec_diff < 0) {
		sec_diff --;
		usec_diff += 1000000;
	}
	printf("CPU Time: %ld.%06ld secs\n", sec_diff, usec_diff);
	return (double)(sec_diff*1.0 + usec_diff/1000.0);
}

int main(int argc, char **argv) {

  if(argc < 4) {

    printf("\nError, too few arguments. Usage: ./queens 1 4 1\n");
    return -1;
  }

  const int NUM_TUPLEX = atoi(argv[1]);
  const int NUM_TUPLEY = atoi(argv[2]);
  int GPUSum = atoi(argv[3]);
  const int generatedNum = NUM - 3 - NUM_TUPLEX;
  long count = 0;
  cudaEvent_t start, stop;
  cudaError_t res;
  float elapsedTime;

  if(generatedNum < 0){
    printf("\nThe numbers generated iteratively cannot be less than 0.\n");
    exit(1);
  }

  //ensure N is in the correct range
  if(NUM < 4  || NUM > 22){
    printf("\nN(%d) must be between 4 and 22 inclusive\n", NUM);
    exit(1);
  }
  if(GPUSum != 0 && GPUSum != 1)
  {
    printf("\nThe GPU sum identifier(%d) must be a 0 or 1, only\n", GPUSum);
    exit(1);
  }

  //ensure that at least one of the tuple values is generated by the block's X coordinate value
  if(NUM_TUPLEX < 1){
    printf("\nThe number of tuples generated by each block's X coordinate value must be >= 1\n");
    exit(1);
  }

  	//ensure that the number of Y segments that the genNum work is divided into
  	//is at least one per work segment
  	if(NUM_TUPLEY > pow(NUM, generatedNum)){
  		printf("\n number of groups of columns must be less than or equal to N^(N - 3 - (1st ARG))\n");
  		exit(1);
  	}

  //CPU setup
  int board[NUM][NUM];

  for (int i = 0; i < NUM; i++) {
    for (int j = 0; j < NUM; j++) {
      board[i][j] = 0;
    }
  }

  int WIDTH = pow(NUM, NUM_TUPLEX);
  int YSegmentSize = (NUM / 2) + (NUM % 2);
  int HEIGHT = YSegmentSize * NUM_TUPLEY;
  int NUM_BLOCKS = WIDTH * HEIGHT;
  answer = (long long *) malloc (sizeof(long long) * NUM_BLOCKS);

  long long *d_answer;
  long *d_count;
  cudaMalloc((void **) &d_count, sizeof(long));
  res = cudaMalloc((void **) &d_answer, sizeof(long long) * NUM_BLOCKS);
  if(res != cudaSuccess) {
    printf("error allocating memory. exiting.\n");
    return 0;
  }

  dim3 block(NUM, NUM);
  dim3 grid(WIDTH, HEIGHT);
  cudaMemcpy(d_count, &count, sizeof(long), cudaMemcpyHostToDevice);

  res = cudaEventCreate(&start);
  if(res != cudaSuccess) {
    printf("error starting event. exiting.\n");
    return 0;
  }
  cudaEventCreate(&stop);
  cudaEventRecord(start, 0);

  kernel<<<grid, block>>>(d_answer, YSegmentSize, NUM_TUPLEX, NUM_TUPLEY, generatedNum, GPUSum, d_count);
  cudaDeviceSynchronize();
  cudaEventRecord(stop, 0);
  cudaEventSynchronize(stop);
  cudaEventElapsedTime(&elapsedTime, start, stop);

  res = cudaMemcpy(answer,d_answer, sizeof(long long) * NUM_BLOCKS, cudaMemcpyDeviceToHost);
  if(res != cudaSuccess) {
    printf("error copying memory. exiting.\n");
    return 0;
  }

  cudaMemcpy(&count, d_count, sizeof(long), cudaMemcpyDeviceToHost);



  const char* errorString = cudaGetErrorString(cudaGetLastError());
  printf("GPU Error: %s\n", errorString);


  if(GPUSum == 0)
  {
    srand(1);
    gettimeofday(&startTime, &Idunno);
    Solver(board, 0, NUM);
    printf("\nTotal sol(CPU): %d boards\n",total);
    report_running_time();
  }
  else if (GPUSum == 1)
  {
    printf("\nTotal sol(GPU): %li boards\n", count);
  }
  printf("GPU Time: %f secs\n\n", (elapsedTime / 1000.00));

   	cudaEventDestroy(start); 
   	cudaEventDestroy(stop);
    	
   	/* Free the allocated device memory. */
   	cudaFree(d_answer);
  
   	//free allocated host memory
 	free(answer);
	
 // printf("\nTotal sol: %d boards\n", sum);
  return 0;

}